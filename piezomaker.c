/*
 * Copyright (C) 2006 Terry Stenvold & Armon Khosravi & Felix Bruns
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "pz.h"
#include <errno.h>
#include <string.h>
#include <sys/stat.h>


static TWidget *wid;
static ttk_surface main_srf;
static ttk_menu_item piezomaker_fbx;
static int pup = 10, dup = 250, box = 1;
static int *period, *duration, size;

#define ISEXT(a,b,c,d) ( (a[0]=='.') && (a[1]==(b) || a[1]==((b)+32)) && (a[2]==(c) || a[2]==((c)+32)) && (a[3]==(d) || a[3]==((d)+32)) )

static int piezomaker_load(char *filename);
static int piezomaker_save_callback(TWidget *swid, char *filename);
static int piezomaker_save();
static float piezomaker_seconds();
static void piezomaker_append();
static void piezomaker_delete();
static void piezomaker_play();
static void piezomaker_draw(TWidget *wid, ttk_surface srf);

static TWindow *new_piezomaker_with_file();

static int piezomaker_openable(const char *filename);
static TWindow * piezomaker_open_handler(ttk_menu_item *item);
static void init_piezomaker();
extern TWidget * ti_new_standard_text_widget(int x, int y, int w, int h, int absheight, char * dt, int (*callback)(TWidget *, char *));
extern int ti_widget_start(TWidget * wid);

static int piezomaker_load(char *filename)
{
	int i = 0, p = 0, d = 0;
	char buffer[80];
	FILE *fp;

	fp = fopen(filename, "r");
	if(!fp){
		pz_error(_("Could not open file for reading."));
		return 1;
	}
	while(fgets(buffer, 80, fp) != NULL){
		if(buffer[0] == '#'){
			continue;
		}
		else if(i == 0){
			size     = atoi(buffer);
			period   = realloc(period,   sizeof(int) * size);
			duration = realloc(duration, sizeof(int) * size);
		}
		else if(i % 2 == 1){
			*(period + p)   = atoi(buffer);
			p++;
		}
		else if(i % 2 == 0){
			*(duration + d) = atoi(buffer);
			d++;
		}
		i++;
	}
	fclose(fp);

	return 0;
}

static int piezomaker_save_callback(TWidget *swid, char *filename)
{
	int i;
	FILE *fp;

	pz_close_window(swid->win);

	fp = fopen(filename, "w");
	if(!fp){
		pz_error(_("Could not save file."));
		return 0;
	}
	fprintf(fp, "#PZM\n#%.2f seconds\n#generated by piezomaker/podzilla\n", piezomaker_seconds());
	fprintf(fp, "%d\n", size);
	for(i=0; i<size; i++){
		fprintf(fp, "%d\n%d\n", *(period+i), *(duration+i));
	}
	fclose(fp);

	free(period);
	free(duration);

	return 0;
}

static int piezomaker_save()
{
	{
		TWindow *ret;
		TWidget *wid;

		ret = ttk_new_window(_("Save to..."));
		wid = ti_new_standard_text_widget(10, 40, ret->w-20, 10+ttk_text_height(ttk_textfont), 0, "/untitled.pzm", piezomaker_save_callback);
		ttk_add_widget(ret, wid);
		ttk_show_window(ret);
		ti_widget_start(wid);
	}

	return 0;
}

static float piezomaker_seconds()
{
	int i;
	float dur = 0;

	for(i=0; i<size; i++){
		dur += *(duration + i);
	}

	return dur/1000;
}

static void piezomaker_append()
{
	size++;
	period   = realloc(period,   sizeof(int) * size);
	duration = realloc(duration, sizeof(int) * size);
	*(period   + size - 1) = pup;
	*(duration + size - 1) = dup;
}

static void piezomaker_delete()
{
	size--;
	if(size < 0){
		size = 0;
	}
	period   = realloc(period,   sizeof(int) * size);
	duration = realloc(duration, sizeof(int) * size);
}

static void piezomaker_play()
{
	int i;

	for (i=0; i<size; i++){
		ttk_click_ex(*(period + i), *(duration + i));
	}
}

static void piezomaker_draw(TWidget *wid, ttk_surface srf)
{
	char buffer[15];
	ttk_color col[2];

	col[0] = ttk_makecol(5, 115, 175); //Blue
	col[1] = ttk_makecol(80, 175, 0);  //Green

	ttk_fillrect(srf, 0, 0, wid->win->w, wid->win->h, ttk_makecol(WHITE));
	ttk_fillrect(main_srf, 5,  5,  50,  35, (box == 1)?col[0]:col[1]);
	ttk_fillrect(main_srf, 55, 5,  100, 35, (box == 2)?col[0]:col[1]);
	ttk_fillrect(main_srf, 5,  40, 50,  70, (box == 3)?col[0]:col[1]);
	ttk_fillrect(main_srf, 55, 40, 100, 70, (box == 4)?col[0]:col[1]);

	sprintf(buffer, "%.2f Seconds", piezomaker_seconds());
	pz_vector_string(srf, buffer, 5,5, 7,7, 1, ttk_makecol(BLACK)); //Seconds	
	sprintf(buffer, "%d", pup);
	pz_vector_string_center(main_srf, buffer, 23,18, 7,7, 1, ttk_makecol(WHITE)); //Period
	sprintf(buffer, "%d", dup);

	pz_vector_string_center(main_srf, buffer, 77,18, 7,7, 1, ttk_makecol(WHITE)); //Duration
	pz_vector_string_center(main_srf, _("Append"), 27,55, 5,7, 1, ttk_makecol(WHITE));
	pz_vector_string_center(main_srf, _("Delete"), 77,55, 5,7, 1, ttk_makecol(WHITE));

	//Blit everything to the screen
	ttk_blit_image (main_srf, srf, (ttk_screen->w/2)-(105/2), ((ttk_screen->h-ttk_screen->wy)/2)-(75/2));
}

static int piezomaker_scroll(TWidget *this,int dir) {
			TTK_SCROLLMOD(dir, 5);
			if(dir > 0){
				switch(box){
					case 1: pup += 1; break;
					case 2: dup += 5; break;
				}
				if(pup > 250){
					pup = 250;
				}
				if(dup > 1000){
					dup = 1000;
				}
				this->dirty++;
			
			}
			else{
				switch(box){
					case 1: pup -= 1; break;
					case 2: dup -= 5; break;
				}
				if(pup < 1){
					pup = 1;
				}
				if(dup < 5){
					dup = 5;
				}
				this->dirty++;
			
			}

	return 0;
	}
static int piezomaker_down(TWidget *this,int button)
{
			switch (button) {
				case TTK_BUTTON_ACTION:
					switch(box){
						case 1: ttk_click_ex(pup, dup); break;
						case 2: ttk_click_ex(pup, dup); break;
						case 3: piezomaker_append();    break; 
						case 4: piezomaker_delete();    break; 
					}
					this->dirty++;
					break;

				case TTK_BUTTON_NEXT:
					box++;
					if(box >= 5){
						box = 1;
					}
					this->dirty++;
					break;

				case TTK_BUTTON_PREVIOUS:
					box--;
					if (box <= 0){
						box = 4;
					}
					this->dirty++;
					break;

				case TTK_BUTTON_MENU:
					piezomaker_save();
					pz_close_window(this->win);
					this->dirty++;
					break;

				case TTK_BUTTON_PLAY:
					piezomaker_play();
					this->dirty++;
					break;

				case TTK_BUTTON_HOLD:
					pz_close_window(this->win);
					this->dirty++;
					break;

				
			}
	
	
	return 0;
}

TWindow *new_piezomaker_with_file(char *filename)
{	
	TWindow *ret;
	
	period    = (int *)malloc(sizeof(int));
	duration  = (int *)malloc(sizeof(int));
	if(period == NULL || duration == NULL) {
		new_message_window("Malloc Failed!");
		return TTK_MENU_DONOTHING;
	}
	else{
		*period   = 0;
		*duration = 0;
		size      = 0;
	}

	piezomaker_load(filename);

	main_srf = ttk_new_surface (105, 75, ttk_screen->bpp);
 	ret      = ttk_new_window("Piezo Maker");
	wid      = ttk_new_widget (0,0);
	wid->focusable=1;
	wid->draw=piezomaker_draw;
	wid->scroll=piezomaker_scroll;
	wid->down=piezomaker_down;
	ttk_add_widget(ret, wid);
ttk_show_window(ret);
	return 0;
}

TWindow *new_piezomaker()
{	
	TWindow *ret;
	
	period    = (int *)malloc(sizeof(int));
	duration  = (int *)malloc(sizeof(int));
	if(period == NULL || duration == NULL) {
		pz_error("Malloc Failed!");
		return TTK_MENU_DONOTHING;
	}
	else{
		*period   = 0;
		*duration = 0;
		size      = 0;
	}

	main_srf = ttk_new_surface (105, 75, ttk_screen->bpp);
 	ret      = ttk_new_window("Piezo Maker");
	wid      = ttk_new_widget (0,0);
	wid->focusable=1;
	wid->draw=piezomaker_draw;
	wid->scroll=piezomaker_scroll;
	wid->down=piezomaker_down;
	ttk_add_widget(ret, wid);
ttk_show_window(ret);
	return 0;
}

static int piezomaker_openable(const char *filename)
{
	char ext[4];
	struct stat st;
	stat(filename, &st);
	if (S_ISDIR(st.st_mode)) return 0;
	strncpy(ext, &filename[strlen(filename)-4], 4);
	if (ext[0] != '.') return 0;
	if (ISEXT(ext, 'P', 'Z', 'M')) return 1;
	return 0;
}

TWindow * piezomaker_open_handler(ttk_menu_item *item)
{
	return new_piezomaker_with_file(item->data);
}

